#!/usr/bin/env python3

"""
Calculates the relevance statistics of ROIs using heatmaps generated by
XAI methods.

Author: Angel Sevilla Molina
source: 
"""

import argparse
import os
import sys
from typing import List
import pandas as pd
import torch

from config_reader import ConfigReader
from rois import ROIManager, ROIAnalyzer


N_FOLDS = 5
N_SPLITS = 30
METHODS = ['gradcam', 'gbp', 'lrp']
MODELS = ['beta1', 'beta2', 'beta3', 'gamma', 'nominal']


def parse_arguments() -> argparse.Namespace:
    """Parses command-line arguments.

    Returns:
      Parsed arguments from the CLI.
    """
    parser = argparse.ArgumentParser(
        description='Performs relevance analysis of ROIs from heatmaps.'
        )
    parser.add_argument('--method', type=str, choices=METHODS, required=True,
        help='XAI technique of the outputs to analyze.')
    parser.add_argument('--model', type=str, choices=MODELS, required=True,
        help='Network model of the outputs to analyze.')
    parser.add_argument('--fold', type=int, choices=range(N_FOLDS), 
        default=None, help='Fold number to analyze. '
                           'If not provided, all folds will be analyzed.')

    return parser.parse_args()


def prepare_columns(rois : dict) -> List[str]:
    """Prepares the columns of the CSV file to be generated.

    Args:
      rois: the region names and maps to be analyzed.

    Returns:
      The header of the columns where relevance data will be stored.
      For each considered ROI, two columns are created, one for each
      measure.
    """
    columns = ['filename']
    for roi in rois:
        columns = columns + [f'{roi.name} mean', f'{roi.name} std']
    return columns


def get_stats_files(
    splits_stats_path : str,
    method : str,
    model : str
) -> List[str]:
    """Gets the names of existing individual statistics files for a
    given method and model.

    Args:
      splits_stats_path: indicates the path to the stats directory.
      method: indicates the name of the XAI technique.
      model: indicates the network configuration.

    Returns:
      All filenames of existing statistics files in the directory,
      corresponding to the specified method and model.
    """
    all_files = os.listdir(splits_stats_path)
    filenames = []

    for filename in all_files:
        if (filename.startswith(f'{method}_{model}_fold') and
                filename.endswith('.csv')):
            filenames.append(filename)

    return filenames


def get_grouped_df(
    splits_stats_path: str,
    filenames: List[str]
) -> pd.DataFrame:
    """Groups the statistics from a set of files, obtaining the mean of
    each measure based on the target class.

    Args:
      splits_stats_path: indicates the path to the stats directory.
      filenames: indicates the names of the files to be grouped.

    Returns:
      A DataFrame containing the mean relevance measures of the files,
      grouped by target class.
    """
    dfs = []

    for filename in filenames:
        df = pd.read_csv(os.path.join(splits_stats_path, filename))
        dfs.append(df)

    grouped_df = pd.concat(dfs, ignore_index=True)
    grouped_df = grouped_df.groupby('target').mean().reset_index()
    grouped_df = grouped_df.set_index('target').transpose().reset_index()
    grouped_df.rename(columns={'index': 'target'}, inplace=True)
    return grouped_df


def group_stats(
    method : str,
    model : str,
    splits_stats_path : str,
    grouped_stats_path : str
) -> None:
    """Generates a CSV file of aggregated statistics for a method and
    model.

    Args:
      method: indicates the name of the XAI technique.
      model: indicates the network configuration.
      splits_stats_path: indicates the path to the stats directory.
      grouped_stats_path: indicates the path to the grouped stats
          directory.
    """
    filenames = get_stats_files(splits_stats_path, method, model)
    grouped_df = get_grouped_df(splits_stats_path, filenames)
    output_path = os.path.join(grouped_stats_path, f'{method}_{model}.csv')
    print(f'Writing statistics file {output_path}')
    grouped_df.to_csv(output_path, index=False)


def main() -> None:
    """Calculates relevance statistics of ROIs from heatmaps
    generated by XAI methods.
    """
    # Read arguments from the parser
    args = parse_arguments()

    # Read the paths from the configuration file
    try:
        config_reader = ConfigReader('config.ini')
        labels_path = config_reader.get_labels_path()
        heatmaps_path = config_reader.get_heatmaps_path()
        splits_stats_path = config_reader.get_splits_stats_path()
        grouped_stats_path = config_reader.get_grouped_stats_path()
    except FileNotFoundError as error:
        sys.exit(f'Error: {error}')
    except KeyError as error:
        sys.exit(f'Error: {error}')

    # Prepare the path to the heatmap directory
    model_path = os.path.join(heatmaps_path, f'{args.method}/{args.model}/')

    # Check if inputs exist
    if args.fold is None:
        if not os.path.isdir(model_path):
            sys.exit('Error: Heatmaps have not been generated for the given '
                     'configuration.')
    else:
        if not os.path.isdir(os.path.join(model_path, f'fold{args.fold}/')):
            sys.exit('Error: Heatmaps have not been generated for the given '
                     'configuration.')

    # Check or create relevance analysis directories
    os.makedirs(splits_stats_path, exist_ok=True)
    os.makedirs(grouped_stats_path, exist_ok=True)

    # Prepare the computing device
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

    # Prepare ROIs
    atlases = ['cort-maxprob-thr25-2mm', 'sub-maxprob-thr25-2mm']
    roi_manager = ROIManager(atlases)
    rois = roi_manager.get_rois()
    roi_analyzer = ROIAnalyzer(device)

    # Prepare dataframe and csv format
    columns = prepare_columns(rois)

    # Load real class labels file
    labels_df = pd.read_csv(labels_path)
    labels_df.drop(labels_df.columns[0], axis=1, inplace=True)

    # If fold is specified, only iterate over that
    if args.fold is not None:
        folds = [args.fold]
    # If not, iterate over all
    else:
        folds = range(N_FOLDS)

    # For each fold
    for fold in folds:
        # For each split
        for split in range(N_SPLITS):
            split_dir = os.path.join(model_path, f'fold{fold}/split{split}/')

            # Check if the directory exists
            if os.path.isdir(split_dir):
                # Store statistics of images in the split
                stats_list = []

                # For each image in the directory:
                for filename in os.listdir(split_dir):
                    if filename.endswith('.pt'):
                        heatmap_path = os.path.join(split_dir, filename)
                        heatmap_t = torch.load(heatmap_path).to(device)
                        stats = roi_analyzer.analyze(heatmap_t, rois)
                        stats['filename'] = filename.split('.')[0] + '.nii.gz'
                        stats_list.append(stats)

                # Calculate DataFrame with analysis
                df = pd.DataFrame(stats_list, columns=columns)

                # Add real class labels to DataFrame
                df = pd.merge(labels_df, df, on='filename', how='inner')
                df = df.sort_values(by='filename')

                # Define output path and store csv file
                output_path = os.path.join(splits_stats_path,
                    f'{args.method}_{args.model}_fold{fold}_split{split}.csv')
                print(f'Writing statistics file {output_path}')
                df.to_csv(output_path, index=False)

    # Group the existing statistics for the method and model
    group_stats(args.method, args.model, splits_stats_path, grouped_stats_path)


if __name__ == '__main__':
    main()
